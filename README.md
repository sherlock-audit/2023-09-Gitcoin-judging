# Issue H-1: `Registry.sol` generate clone `Anchor.sol` never work. Profile owner cannot use their `Anchor` wallet 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/380 

## Found by 
0xG0P1, 0xnirlin, Arz, KingNFT, VAD37, niluk, pinalikefruit, zach030
User create new profile through `Registry`. Each profile have its own unique `Anchor` clone contract to handle transactions as a wallet.
New clone `Anchor.sol` contract never work because `registry` address setup in `Anchor` constructor point to wrong address.
This broke `Anchor` contract. Profile owner cannot use their wallet `Anchor`. All funds send to this `Anchor` contract will be lost forever.

## Vulnerability Detail

Add this test to `Registry.t.sol` test file to reproduce the issue.

```js
    function test_Audit_createProfile() public {
        // create profile
        bytes32 newProfileId = registry().createProfile(nonce, name, metadata, profile1_owner(), profile1_members());
        Registry.Profile memory profile = registry().getProfileById(newProfileId);
        Anchor _anchor = Anchor(payable(profile.anchor));

        console.log("registry address: %s", address(registry()));
        console.log("anchor address: %s", profile.anchor);
        console.log("anchor.registry: %s", address(_anchor.registry()));

        emit log_named_bytes32("profile.id", profile.id);
        emit log_named_bytes32("anchor.profile.id", _anchor.profileId());

        Anchor _anchor_proxy = Anchor(payable(address( _anchor.registry())));
        assertEq(address(registry()),address(_anchor.registry()) ,"wrong anchor registry");
    }
```

What happen with `Anchor.sol` is it expect `msg.sender` is `Registry` contract. But in reality `msg.sender` is a proxy contract generated by Solady during `CREATE3` operation.

```solidity
    constructor(bytes32 _profileId) {
        registry = Registry(msg.sender);//@audit H Registry address here is not Registry. msg.sender is a proxy contract. Create3 deploy 2 contract. one is proxy. other is actual bytecode.
        profileId = _profileId;
    }
```

This can be seen with Solady comment for proxy contract. `msg.sender` above is middleman proxy contract. Not `Registry` contract. Solady generate 2 contract during CREATE3 operation. [One is proxy](https://github.com/Vectorized/solady/blob/62301983801a898fcfaad6fa492f21350d31b5aa/src/utils/CREATE3.sol#L34) contract. [Second is actual bytecode](https://github.com/Vectorized/solady/blob/62301983801a898fcfaad6fa492f21350d31b5aa/src/utils/CREATE3.sol#L72).

## Impact

`Anchor.execute()` function will not work because `registry` address point to empty proxy contract and not actual `Registry` so all call will revert.
```solidity
File: allo-v2\contracts\core\Anchor.sol
70:     function execute(address _target, uint256 _value, bytes memory _data) external returns (bytes memory) {
71:         // Check if the caller is the owner of the profile and revert if not
72:         if (!registry.isOwnerOfProfile(profileId, msg.sender)) revert UNAUTHORIZED();
```
Profile owner cannot use their wallet `Anchor`. All funds send to this `Anchor` contract will be lost forever.
## Code Snippet


https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/core/Registry.sol#L350
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/core/Anchor.sol#L55-L58

## Tool used

Manual Review

## Recommendation

Move `msg.sender` into constructor parameter
```solidity
File: allo-v2\contracts\core\Registry.sol
347:             bytes memory creationCode = abi.encodePacked(type(Anchor).creationCode, abi.encode(_profileId, address(this))); //@audit fix creation code
348: 
349:             // Use CREATE3 to deploy the anchor contract
350:             anchor = CREATE3.deploy(salt, creationCode, 0); 
File: allo-v2\contracts\core\Anchor.sol
55:     constructor(bytes32 _profileId, address _registry) {
56:         registry = Registry(_registry);
57:         profileId = _profileId;
58:     }
```

# Issue H-2: Missing access modifier for `RFPSimpleStrategy.setPoolActive()` may lead to multiple issues 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/458 

## Found by 
0x00ffDa, 0x180db, 0x3b, 0xMAKEOUTHILL, 0xMosh, 0xRstStn, 0xSurena, 0xaghas, 0xarno, 0xbepresent, 0xblackskull, 0xc0ffEE, 0xdeadbeef, 0xgoat, 0xkaden, ArmedGoose, Arz, AsenXDeth, Bauchibred, BenRai, BugHunter101, CL001, CRYP70, Cryptor, DevABDee, GimelSec, HChang26, HHK, IceBear, Inspex, KingNFT, Kodyvim, Kow, Kral01, Martians, Milad-Sha, MohammedRizwan, Nyx, ReadyPlayer2, SBSecurity, SV, Silvermist, TabFoxOne, Vagner, WATCHPUG, Yashar, ZdravkoHr., ace13567, adeolu, al88nsk, alexweb3, alymurtazamemon, anarcheuz, ast3ros, asui, branch\_indigo, bronze\_pickaxe, bugzyvonbuggernaut, cammamoon, chaduke, dany.armstrong90, dopeflamingo, fibonacci, fishgang, gkrastenov, grearlake, hals, hindsight, honeymewn, imare, imsrybr0, inallhonesty, its\_basu, jah, jkoppel, kn0t, lemonmon, lil.eth, marchev, mike-watson, mitko1111, nobody2018, osmanozdemir1, p0wd3r, parsely, pengun, pinalikefruit, pontifex, qbs, rvierdiiev, sandNallani, sashik\_eth, seeques, shirochan, simon135, tnquanghuy0512, toshii, tpiliposian, twcctop, unix515, ustas, vagrant, wangxx2026, xAriextz, y4y, yegorre
`RFPSimpleStrategy.setPoolActive()` can be called by anybody since it's missing the `onlyPoolManager(msg.sender)` modifier, which can be abused by a malicious actor to steal funds.

## Vulnerability Detail

The comment on line 217 in RFPSimpleStrategy.sol says that `'msg.sender' must be a pool manager` in order to be able to call `RFPSimpleStrategy.setPoolActive()`. However, the necessary `onlyPoolManager(msg.sender)` modifier is missing.

## Impact

Multiple functions inside `RFPSimpleStrategy.sol` are either using the `onlyActivePool` or the `onlyInactivePool` modifiers:

* `RFPSimpleStrategy._distribute()`
* `RFPSimpleStrategy.withdraw()`
* `RFPSimpleStrategy._registerRecipient()`
* `RFPSimpleStrategy._allocate()`

A malicious actor (Alice) might do the following for example:

1. Alice registers themself as recipient for a `RFPSimpleStrategy`, specifying a `proposalBid` which is `15e18`.
1. Alice is being declared as the accepted recipient by the pool manager.
1. Now if the tokens were distributed to Alice, the amount of tokens Alice would receive would be `(15e18 * milestone.amountPercentage) / 1e18` (line 435 RFPSimpleStrategy.sol).
1. However, Alice calls `RFPSimpleStrategy.setPoolActive()` to make the pool active again, before the tokens are distributed. Alice might do this by either frontrunning or by executing the tx earlier.
1. Now Alice can call `RFPSimpleStrategy._registerRecipient()`, since the pool is active again, and Alice re-registers themself but with a higher `proposalBid` than was accepted before (line 378 RFPSimpleStrategy.sol), for example they re-register with a `proposalBid` of `60e18`.
1. Then Alice calls `RFPSimpleStrategy.setPoolActive()` to set the pool inactive, so that the tokens can be distributed.
1. Now when the tokens are distributed to Alice for the first milestone (and later also for subsequent milestones), they receive a much higher amount of tokens, since Alice maliciously increased their accepted `proposalBid` from `15e18` to `60e18`, so they would now receive `(60e18 * milestone.amountPercentage) / 1e18` (line 435 RFPSimpleStrategy.sol) which is more than was accepted.

The above example illustrates how Alice can abuse setting the pool to active and inactive to change their accepted `proposalBid` to receive more tokens.

Also, Alice could potentially steal funds from the strategy, if they get accepted with a smaller `proposalBid` and then maliciously increase the `proposalBid` as described in the above example, so that Alice would receive a much higher amount of tokens that they are not eligible to receive and that are effectively being stolen from the funds of the strategy.

## Code Snippet

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L217-L221

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L417-L450

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L314-L380

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L386-L393

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L295


## Tool used

Manual Review

## Recommendation

Consider adding the missing access modifier `onlyPoolManager(msg.sender)` to `RFPSimpleStrategy.setPoolActive()`.

# Issue H-3: Malicious registrant can front-run `RFPSimpleStrategy._allocate()` in order to change the `proposalBid` and get a bigger payout in the distribution 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/497 

## Found by 
0xbepresent, 0xdeadbeef, WATCHPUG, detectiveking, honeymewn, jah, qbs, rvierdiiev
The `RFPSimpleStrategy::_allocate()` function can be frontrun by a malicious `registrant` chainging the `proposalBid` and get a bigger payout in the `RFPSimpleStrategy::_distribute()` function.

## Vulnerability Detail

Users can register to the pool strategy using the [RFPSimpleStrategy::_registerRecipient()](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L314C14-L314C32) function specifying the [proposalBid](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L378) in the registration. Then the pool manager [accepts the `registrant recipient`](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L404) using the [RFPSimpleStrategy::_allocate()](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L386) function.

The problem is that the execution of the `RFPSimpleStrategy::_allocate()` function by the `pool manager` can be frontun by a malicious `registrant recipient`. Consider the next scenario:

1. `UserA` call the `RFPSimpleStrategy::_registerRecipient()` using a `proposalBid=10`.
2. Pool manager accepts the proposal by `UserA` and call the `RFPSimpleStrategy::_allocate()` function.
3. `UserA` monitors the mempool and frontrun the manager `_allocate()` execution changing the proposal now `proposalBid=50`.
4. The `step 2` call finally is executed but the using non-agreed proposal `proposalBid=50`.

Now the `UserA` is accepted registrant recipient with non-agreed proposal bid (`proposalBid=50`).

## Impact

Malicious registrant can change the `proposalBid` to a non-agreed term causing that he can receive a bigger payout in the [RFPSimpleStrategy::_distribute()](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L417) function because in the [code line 435](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L435) the `proposalBid` is used to calculate the amount to pay to the `accepted registrant recipient`:

```solidity
File: RFPSimpleStrategy.sol
417:     function _distribute(address[] memory, bytes memory, address _sender)
418:         internal
419:         virtual
420:         override
421:         onlyInactivePool
422:         onlyPoolManager(_sender)
423:     {
...
...
433: 
434:         // Calculate the amount to be distributed for the milestone
435:         uint256 amount = (recipient.proposalBid * milestone.amountPercentage) / 1e18;
436: 
437:         // Get the pool, subtract the amount and transfer to the recipient
438:         poolAmount -= amount;
439:         _transferAmount(pool.token, recipient.recipientAddress, amount);
...
...
450:     }
```

The malicious accepted registrant can drain all funds from the pool strategy using one milestone.

## Code Snippet

- [RFPSimpleStrategy::_registerRecipient()](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L314C14-L314C32)
- [RFPSimpleStrategy::_allocate()](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L386)
- [RFPSimpleStrategy::_distribute()](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L417)

## Tool used

Manual review

## Recommendation

Verify the `proposalBid` when the `_allocate()` occurs:

```diff
    function _allocate(bytes memory _data, address _sender)
        internal
        virtual
        override
        nonReentrant
        onlyActivePool
        onlyPoolManager(_sender)
    {
        // Decode the '_data'
--      acceptedRecipientId = abi.decode(_data, (address));
++      (acceptedRecipientId, uint256 expectedProposalBid) = abi.decode(_data, (address, uint256));

        Recipient storage recipient = _recipients[acceptedRecipientId];

--      if (acceptedRecipientId == address(0) || recipient.recipientStatus != Status.Pending) {
++      if (acceptedRecipientId == address(0) || recipient.recipientStatus != Status.Pending || recipient.proposalBid != expectedProposalBid) {
            revert RECIPIENT_ERROR(acceptedRecipientId);
        }

        // Update status of acceptedRecipientId to accepted
        recipient.recipientStatus = Status.Accepted;

        _setPoolActive(false);

        IAllo.Pool memory pool = allo.getPool(poolId);

        // Emit event for the allocation
        emit Allocated(acceptedRecipientId, recipient.proposalBid, pool.token, _sender);
    }
```



## Discussion

**thelostone-mc**

Yup this does feel safer. The only downside is that the pool manager could now put in a big lower than what was proposed by the recipient but this seems alright as the pool manager is a trusted actor 

# Issue M-1: Token lockup vulnerability in _afterAllocate function 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/14 

## Found by 
Japy69
The `DonationVotingMerkleDistributionVaultStrategy.sol` smart contract is susceptible to a front-running attack during the execution of the `_afterAllocate` function, specifically when using the `permitTransferFrom` function from the Uniswap permit2 contract. This vulnerability arises because a malicious user can front-run the transaction, calling the `permitTransferFrom` function with the same parameters and the same signature. This action results in tokens being sent to the smart contract but without updating the total payout amount for the claim.
Furthermore, the user's transaction will subsequently revert due to protections on Uniswap permit2 contract against replay attacks, causing some user tokens to become permanently stuck within the `DonationVotingMerkleDistributionVaultStrategy.sol` contract.

## Vulnerability Detail

The vulnerability occurs when a user interacts with the `DonationVotingMerkleDistributionVaultStrategy.sol` contract and attempts to use the `permitTransferFrom` function from the Uniswap permit2 contract. A malicious user can see the transaction in the mempool and front-run the transaction. By doing so, he can call `permitTransferFrom` with the exact same parameters, leading to the transfer of tokens to the smart contract as desired. However, the total payout amount for the claim is not updated because the malicious user send tokens to the contract directly, and did not by the `_afterAllocate`. Additionally, the user's transaction would revert, because of the protection against replay attacks, resulting in some tokens being permanently locked within the smart contract.

Let's take an example, taking the [sequence diagram](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-distribution-vault/README.md#sequence-diagram) to facilitate.

All the workflow is the same.

1. When Bob calls `allocate()`, the front-runner bot see it.
2. Then the front-runner is able to know each parameter of the call.
3. He converts this data, then he has:
- `p2Data.permit`
- `amount`
- `_sender`
- `p2Data.signature`
4. He calls the permit2 contract with following parameters: 
```solidity
    permitTransferFrom(
        p2Data.permit,
        ISignatureTransfer.SignatureTransferDetails({to: [STRATEGY_CONTRACT_ADDRESS], requestedAmount: amount}),
        _sender,
        p2Data.signature
    )
```
5. Tokens are well received.
6. Bob's transaction revert because the signature was already used.
7. `claims[recipientId][token] += amount` was not done. So `recipientId` will not be able to claim tokens.

Tokens are now frozen on the contract.

## Impact

The impact of this vulnerability is significant. A malicious user exploiting this issue can effectively lock tokens within the `DonationVotingMerkleDistributionVaultStrategy.sol` contract without properly updating the total payout amount for the claim. This can result in a discrepancy between the claimed and actual token balances, leading to potential financial losses for the affected users. Furthermore, the user's transaction reverting can further complicate the situation, making it impossible to recover the locked tokens.

## Code Snippet

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-distribution-vault/DonationVotingMerkleDistributionVaultStrategy.sol#L121-L132

## Tool used

Manual Review

## Recommendation

To mitigate this vulnerability and prevent potential token lockups and discrepancies, it is recommended to revise the contract's logic. I recommend to delete the Uniswap permit2 feature and to only allow simple `transferFrom` calls.

# Issue M-2: `fundPool` does not work with fee-on-transfer token 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/19 

## Found by 
0x00ffDa, 0x1337, 0x180db, 0x6980, 0xHelium, 0xMosh, 0xbepresent, 0xdeadbeef, 0xgoat, Aamirusmani1552, ArmedGoose, Arz, AsenXDeth, BenRai, DevABDee, Inspex, JP\_Courses, Kodyvim, Kow, Martians, Proxy, Silvermist, Tri-pathi, Vagner, WATCHPUG, ZdravkoHr., ace13567, adeolu, alexzoid, alymurtazamemon, ashirleyshe, ast3ros, cats, detectiveking, foresthalberd, grearlake, hals, imsrybr0, inspecktor, inzinko, jkoppel, lealCodes, lemonmon, lil.eth, marchev, nobody2018, osmanozdemir1, p0wd3r, parsely, pavankv241, pengun, pontifex, qbs, rvierdiiev, seeques, shtesesamoubiq, theclonedtyroneidgafmf, trevorjudice, tsvetanovv, vagrant, xAriextz
## Vulnerability Detail
In `_fundPool`, the parameter for `increasePoolAmount` is directly the amount used in the `transferFrom` call.

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/core/Allo.sol#L516-L517
```solidity
        _transferAmountFrom(_token, TransferData({from: msg.sender, to: address(_strategy), amount: amountAfterFee}));
        _strategy.increasePoolAmount(amountAfterFee);
```

When `_token` is a fee-on-transfer token, the actual amount transferred to `_strategy` will be less than `amountAfterFee`. Therefore, the current approach could lead to a recorded balance that is greater than the actual balance.
## Impact
`fundPool` does not work with fee-on-transfer token
## Code Snippet
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/core/Allo.sol#L516-L517
## Tool used

Manual Review

## Recommendation
Use the change in `_token` balance as the parameter for `increasePoolAmount`.

# Issue M-3: Exponential Inflation of Voice Credits in Quadratic Voting Strategy 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/48 

## Found by 
0x00ffDa, 0x3b, 0xRstStn, 0xarno, 0xbepresent, 0xc0ffEE, 0xdeadbeef, 0xkaden, 0xpoolbaer, Arz, AsenXDeth, BenRai, GimelSec, HChang26, HHK, KingNFT, Kow, Topmark, WATCHPUG, ZdravkoHr., ace13567, alexxander, ashirleyshe, ast3ros, chaduke, coffiasd, dany.armstrong90, detectiveking, honeymewn, jah, jkoppel, jovi, lemonmon, lil.eth, nobody2018, osmanozdemir1, pengun, pontifex, rvierdiiev, seeques, shtesesamoubiq, simon135, tnquanghuy0512, toshii, trachev, twcctop

## Vulnerability Detail
In the given code snippet, we observe a potential issue in the way voice credits are being accumulated for each recipient. The specific lines of code in question are:
```solidity
function _qv_allocate(
        ...
    ) internal onlyActiveAllocation {
        ...
        uint256 creditsCastToRecipient = _allocator.voiceCreditsCastToRecipient[_recipientId];
        ...
        // get the total credits and calculate the vote result
        uint256 totalCredits = _voiceCreditsToAllocate + creditsCastToRecipient;
        ...
        //E update allocator mapping voice for this recipient
        _allocator.voiceCreditsCastToRecipient[_recipientId] += totalCredits; //E @question should be only _voiceCreditsToAllocate
        ...
    }
```
We can see that at the end : 
```solidity
_allocator.voiceCreditsCastToRecipient[_recipientId] = _allocator.voiceCreditsCastToRecipient[_recipientId] + _voiceCreditsToAllocate +  _allocator.voiceCreditsCastToRecipient[_recipientId];
```

Here, totalCredits accumulates both the newly allocated voice credits (`_voiceCreditsToAllocate`) and the credits previously cast to this recipient (`creditsCastToRecipient`). Later on, this totalCredits is added again to `voiceCreditsCastToRecipient[_recipientId]`, thereby including the previously cast credits once more

### Proof of Concept (POC):
Let's consider a scenario where a user allocates credits in three separate transactions:

1. Transaction 1: Allocates 5 credits
- creditsCastToRecipient initially is 0
- totalCredits = 5 (5 + 0)
- New voiceCreditsCastToRecipient[_recipientId] = 5

2. Transaction 2: Allocates another 5 credits
- creditsCastToRecipient now is 5 (from previous transaction)
- totalCredits = 10 (5 + 5)
- New voiceCreditsCastToRecipient[_recipientId] = 15 (10 + 5)

3. Transaction 3: Allocates another 5 credits
- creditsCastToRecipient now is 15
- totalCredits = 20 (5 + 15)
- New voiceCreditsCastToRecipient[_recipientId] = 35 (20 + 15)

From the above, we can see that the voice credits cast to the recipient are exponentially growing with each transaction instead of linearly increasing by 5 each time

## Impact
Exponential increase in the voice credits attributed to a recipient, significantly skewing the results of the voting strategy( if one recipient receive 15 votes in one vote and another one receive 5 votes 3 times, the second one will have 20 votes and the first one 15)
Over time, this could allow for manipulation and loss of trust in the voting mechanism and the percentage of amount received by recipients as long as allocations are used to calculate the match amount they will receive from the pool amount.

## Code Snippet

https://github.com/allo-protocol/allo-v2/blob/main/contracts/strategies/qv-base/QVBaseStrategy.sol#L529

## Tool used

Manual Review

## Recommendation
Code should be modified to only add the new voice credits to the recipient's tally. The modified line of code should look like:
```solidity
_allocator.voiceCreditsCastToRecipient[_recipientId] += _voiceCreditsToAllocate;
```

# Issue M-4: `QVSimpleStrategy` never updates `allocator.voiceCredits`. 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/150 

## Found by 
0x00ffDa, 0x3b, 0xMAKEOUTHILL, 0xarno, 0xbepresent, 0xkaden, Arz, BenRai, GimelSec, HChang26, HHK, Kodyvim, Kow, Kral01, Martians, Nyx, WATCHPUG, ZdravkoHr., al88nsk, alexxander, ashirleyshe, ast3ros, bronze\_pickaxe, carrotsmuggler, chaduke, coffiasd, cu5t0mPe0, dany.armstrong90, detectiveking, dipp, fibonacci, jah, jkoppel, jovi, lemonmon, lil.eth, nobody2018, osmanozdemir1, pengun, pontifex, qbs, rvierdiiev, sandNallani, seeques, simon135, tnquanghuy0512, toshii, wangxx2026
Every allocator in `QVSimpleStrategy` has a maximum credit limit. An allocator should not be able to bypass the limit. However, `QVSimpleStrategy` fails to record the allocated votes. An allocator can vote as many as possible.

## Vulnerability Detail

`QVSimpleStrategy._allocate` calls `_hasVoiceCreditsLeft` to check that the recipient has voice credits left to allocate.
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-simple/QVSimpleStrategy.sol#L121
```solidity
    function _allocate(bytes memory _data, address _sender) internal virtual override {
        …

        // check that the recipient has voice credits left to allocate
        if (!_hasVoiceCreditsLeft(voiceCreditsToAllocate, allocator.voiceCredits)) revert INVALID();

        _qv_allocate(allocator, recipient, recipientId, voiceCreditsToAllocate, _sender);
    }
```

`QVSimpleStrategy._hasVoiceCreditsLeft` checks ` _voiceCreditsToAllocate + _allocatedVoiceCredits <= maxVoiceCreditsPerAllocator`
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-simple/QVSimpleStrategy.sol#L144
```solidity
    function _hasVoiceCreditsLeft(uint256 _voiceCreditsToAllocate, uint256 _allocatedVoiceCredits)
        internal
        view
        override
        returns (bool)
    {
        return _voiceCreditsToAllocate + _allocatedVoiceCredits <= maxVoiceCreditsPerAllocator;
    }
```

The problem is that `allocator.voiceCredits` is always zero. Both `QVSimpleStrategy` and `QVBaseStrategy` don't update `allocator.voiceCredits`. Thus, allocators can cast more votes than `maxVoiceCreditsPerAllocator`.

## Impact

Every allocator has an unlimited number of votes.

## Code Snippet

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-simple/QVSimpleStrategy.sol#L121
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-simple/QVSimpleStrategy.sol#L144


## Tool used

Manual Review

## Recommendation

Updates `allocator.voiceCredits` in  `QVSimpleStrategy._allocate`.

```diff
    function _allocate(bytes memory _data, address _sender) internal virtual override {
        …

        // check that the recipient has voice credits left to allocate
        if (!_hasVoiceCreditsLeft(voiceCreditsToAllocate, allocator.voiceCredits)) revert INVALID();
+       allocator.voiceCredits += voiceCreditsToAllocate;
        _qv_allocate(allocator, recipient, recipientId, voiceCreditsToAllocate, _sender);
    }
```

# Issue M-5: RFPSimpleStrategy milestones can be set multiple times 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/176 

## Found by 
GimelSec, HChang26, Martians, WATCHPUG, ace13567, chaduke, fibonacci, jkoppel, lemonmon, osmanozdemir1
Until the first distribution is completed, it's possible to call `setMilestones` function multiple times. New milestones are added to the previous ones. The `totalAmountPercentage` of all milestones in this case will be greater than 100%. It also affects all the contracts that are inherited from RFPSimpleStrategy.

## Vulnerability Detail

The `setMilestones` function in `RFPSimpleStrategy` contract checks if `MILESTONES_ALREADY_SET` or not by `upcomingMilestone` index.

```solidity
if (upcomingMilestone != 0) revert MILESTONES_ALREADY_SET();
```

But `upcomingMilestone` increases only after distribution, and until this time will always be equal to 0.

## Impact

It can accidentally break the pool state or be used with malicious intentions.

1. Two managers accidentally set the same milestones. Milestones are duplicated and can't be reset, the pool needs to be recreated.
2. The manager, in cahoots with the recipient, sets milestones one by one, thereby bypassing `totalAmountPercentage` check and increasing the payout amount.

## Code Snippet

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L224-L247

## Tool used

Manual Review

## Recommendation

Fix condition if milestones should only be set once. 

```solidity
if (milestones.length > 0) revert MILESTONES_ALREADY_SET();
```

Or allow milestones to be reset while they are not in use.


```solidity
if (milestones.length > 0) {
    if (milestones[0].milestoneStatus != Status.None) revert MILESTONES_ALREADY_IN_USE();
    delete milestones;
}
```

# Issue M-6: `recipientsCounter` should start from 1 in `DonationVotingMerkleDistributionBaseStrategy` 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/199 

## Found by 
0xkaden, 0xnirlin, GimelSec, Kow, branch\_indigo, nobody2018
When doing `DonationVotingMerkleDistributionBaseStrategy._registerRecipient`, it checks the current status of the recipient. If the recipient is new to the pool, the status should be `Status.None`. However, `recipientsCounter` starts from 0. The new recipient actually gets the status of first recipient of the pool.

## Vulnerability Detail

`DonationVotingMerkleDistributionBaseStrategy._registerRecipient` calls `_getUintRecipientStatus` to get the current status of the application. The status of the new application should be `Status.None`. Then, the `recipientToStatusIndexes[recipientId]`  to `recipientsCounter` and `recipientsCounter`.
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L580
```solidity
    function _registerRecipient(bytes memory _data, address _sender)
        internal
        override
        onlyActiveRegistration
        returns (address recipientId)
    {
        …

        uint8 currentStatus = _getUintRecipientStatus(recipientId);

        if (currentStatus == uint8(Status.None)) {
            // recipient registering new application
            recipientToStatusIndexes[recipientId] = recipientsCounter;
            _setRecipientStatus(recipientId, uint8(Status.Pending));

            bytes memory extendedData = abi.encode(_data, recipientsCounter);
            emit Registered(recipientId, extendedData, _sender);

            recipientsCounter++;
        } else {
            if (currentStatus == uint8(Status.Accepted)) {
                // recipient updating accepted application
                _setRecipientStatus(recipientId, uint8(Status.Pending));
            } else if (currentStatus == uint8(Status.Rejected)) {
                // recipient updating rejected application
                _setRecipientStatus(recipientId, uint8(Status.Appealed));
            }
            emit UpdatedRegistration(recipientId, _data, _sender, _getUintRecipientStatus(recipientId));
        }
    }
```

`DonationVotingMerkleDistributionBaseStrategy._getUintRecipientStatus` calls `_getStatusRowColumn` to get the column index and current row.
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L819
```solidity
    function _getUintRecipientStatus(address _recipientId) internal view returns (uint8 status) {
        // Get the column index and current row
        (, uint256 colIndex, uint256 currentRow) = _getStatusRowColumn(_recipientId);

        // Get the status from the 'currentRow' shifting by the 'colIndex'
        status = uint8((currentRow >> colIndex) & 15);

        // Return the status
        return status;
    }
```

`DonationVotingMerkleDistributionBaseStrategy._getStatusRowColumn` computes indexes from `recipientToStatusIndexes[_recipientId]`. For the new recipient. Those indexes should be zero.
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L833
```solidity
    function _getStatusRowColumn(address _recipientId) internal view returns (uint256, uint256, uint256) {
        uint256 recipientIndex = recipientToStatusIndexes[_recipientId];

        uint256 rowIndex = recipientIndex / 64; // 256 / 4
        uint256 colIndex = (recipientIndex % 64) * 4;

        return (rowIndex, colIndex, statusesBitMap[rowIndex]);
    }
```

The problem is that `recipientCounter` starts from zero.
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L166
```solidity
    /// @notice The total number of recipients.
    uint256 public recipientsCounter;
```

Consider the following situation:
* Alice is the first recipient calls `registerRecipient`
```solidity
// in _registerRecipient
recipientToStatusIndexes[Alice] = recipientsCounter = 0;
_setRecipientStatus(Alice, uint8(Status.Pending));
recipientCounter++
```
* Bob calls `registerRecipient`.
```solidity
// in _getStatusRowColumn
recipientToStatusIndexes[Bob] = 0 // It would access the status of Alice
// in _registerRecipient
currentStatus = _getUintRecipientStatus(recipientId) = Status.Pending
currentStatus != uint8(Status.None) -> no new application is recorded in the pool.
```

This implementation error makes the pool can only record the first application.

## Impact

## Code Snippet

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L580
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L819
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L833
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L166

## Tool used

Manual Review

## Recommendation

Make the counter start from 1. There are two methods to fix the  issue.

1.
```diff
    /// @notice The total number of recipients.
+   uint256 public recipientsCounter;
-   uint256 public recipientsCounter;
```

2.
```diff
    function _registerRecipient(bytes memory _data, address _sender)
        internal
        override
        onlyActiveRegistration
        returns (address recipientId)
    {
        …

        uint8 currentStatus = _getUintRecipientStatus(recipientId);

        if (currentStatus == uint8(Status.None)) {
            // recipient registering new application
+           recipientToStatusIndexes[recipientId] = recipientsCounter + 1;
-           recipientToStatusIndexes[recipientId] = recipientsCounter;
            _setRecipientStatus(recipientId, uint8(Status.Pending));

            bytes memory extendedData = abi.encode(_data, recipientsCounter);
            emit Registered(recipientId, extendedData, _sender);

            recipientsCounter++;
        …
    }
```

# Issue M-7: QVStrategy : Funds locked if no registered recipient or no recipientStatus >= reviewThreshold 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/207 

## Found by 
lil.eth
However QVStrategy doesn't have one , so in case of no registration or no acceptation of a recipient before `registrationEndTime` is passed  , funds deposited on the strategy contract will be lock.

## Vulnerability Detail
As explained above, both RFP and Merkle strategies have withdraw() function : 

- DonationVotingMerkleDistributionBaseStrategy.sol : 
```solidity
    function withdraw(uint256 _amount) external onlyPoolManager(msg.sender) {
        //E must be one month after allocationEndTime
        if (block.timestamp <= allocationEndTime + 30 days) {
            revert INVALID();
        }
        IAllo.Pool memory pool = allo.getPool(poolId);
        if (_amount > poolAmount) { 
            revert INVALID();
        }
        poolAmount -= _amount;
        // Transfer the tokens to the 'msg.sender' (pool manager calling function)
        _transferAmount(pool.token, msg.sender, _amount);
    }
```

- RFPSimpleStrategy.sol : 
```solidity
    function withdraw(uint256 _amount) external onlyPoolManager(msg.sender) onlyInactivePool {
        // Decrement the pool amount
        poolAmount -= _amount;
        // Transfer the amount to the pool manager
        _transferAmount(allo.getPool(poolId).token, msg.sender, _amount);
    }
```
But QV strategy doesn't implement an in-built withdraw function, so the only process to distribute funds locked on a QV Strategy would be to have a recipient reviewed by `poolManager` more than `reviewThreshold` time before `registrationEndTime` :
```solidity
//E Add 1 Review for recipient(s) application(s) and set status of the corresponding recipient struct ONLY if it passes the threshold
    function reviewRecipients(address[] calldata _recipientIds, Status[] calldata _recipientStatuses) external virtual
        onlyPoolManager(msg.sender)  //E if hasRole(pools[_poolId].managerRole, _address) || _isPoolAdmin(_poolId, _address);
        onlyActiveRegistration
    {
        .....
        for (uint256 i; i < recipientLength;) {
            ....
            //E mapping(address => mapping(Status => uint256)) public reviewsByStatus; //E recipientId -> status -> count
            reviewsByStatus[recipientId][recipientStatus]++;

            //E check if it passed threshold of reviewing
            if (reviewsByStatus[recipientId][recipientStatus] >= reviewThreshold) { //E @question what if reviewThreshold change ? PoolManager has to resend this tx
                Recipient storage recipient = recipients[recipientId];
                recipient.recipientStatus = recipientStatus;
                emit RecipientStatusUpdated(recipientId, recipientStatus, address(0));
            }
           ...
        }
    }
```
And then have a poolManager calling `_distribute()` function using Allo.sol (this function can be called anytime after `allocationEndTime`)

**However if no recipient passes `reviewThreshold` or no recipient at all register for this strategy, funds will be locked on the strategy contract.**
(We could think about modifying timestamps using `updatePoolTimestamps()` but this function reverts `if block.timestamp > _registrationStartTime`)
**So once the process of registration is launch on a QV Strategy there is no other possibilities to unlock the funds than having a recipient registering and accepted before end of `registrationEndTime`, if one of these conditions failed, funds will be locked.**

I validate this problem with sponsor who answered "Ah you're right ! We should have a withdraw function. Good catch on that"

## Impact

If between `registrationStartTime` and `registrationEndTime` there is no accepted registration , funds will be locked on this contract with no way to unlock them.

## Code Snippet

https://github.com/allo-protocol/allo-v2/blob/main/contracts/strategies/qv-base/QVBaseStrategy.sol#L369

## Tool used

Manual Review

## Recommendation

Add a `withdraw()` function for `poolManagers` on the QV Strategy in the same model as there is one in RFP Strategy


NB : it is also true if valid allocator forgets to vote as amount sent is calculated in `_getPayout()` function only if `totalRecipientVotes != 0` and even if this case would be strange it would necessite a `withdraw()` function



## Discussion

**sherlock-admin**

1 comment(s) were left on this issue during the judging contest.

**n33k** commented:
> invalid, fund are recoverable, but better to fix



**neeksec**

Re-reviewed the report, looks like a valid finding. Reopen and bring sponsor to review.

**neeksec**

Although the fix is the same with #446, the root cause of fund locking in this submission is different with #446.

So I would keep it a different issue from #446.

# Issue M-8: The `RFPSimpleStrategy._registerRecipient()` does not work when the strategy was created using the `useRegistryAnchor=true` causing that nobody can register to the pool 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/245 

## Found by 
0xMAKEOUTHILL, 0xarno, 0xbepresent, 0xnirlin, GimelSec, HHK, KingNFT, Kow, Martians, Nyx, SBSecurity, Vagner, WATCHPUG, ace13567, alexxander, ashirleyshe, ast3ros, fibonacci, fishgang, hindsight, jah, jkoppel, nobody2018, osmanozdemir1, pontifex, rvierdiiev, sashik\_eth, tnquanghuy0512, toshii, unix515, ustas, xAriextz, zach030
The [RFPSimpleStrategy._registerRecipient()](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L314) does not work when the strategy was created using the `useRegistryAnchor=true` causing that no one can register to the pool and the funds sent to the pool may be trapped.

## Vulnerability Detail

The `RFPSimpleStrategy` strategies can be created using the `useRegistryAnchor` which indicates whether to use the registry anchor or not. If the pool is created using the `useRegistryAnchor=true` the [RFPSimpleStrategy._registerRecipient()](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L314) will be reverted by [RECIPIENT_ERROR](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L362C52-L362C67). The problem is that when `useRegistryAnchor` is true, the variable [recipientAddress is not collected](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L329-L332) so the function will revert by the [RECIPIENT_ERROR](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L362).

I created a test where the strategy is created using the `userRegistryAnchor=true` then the `registerRecipient()` will be reverted by the `RECIPIENT_ERROR`.

```solidity
// File: test/foundry/strategies/RFPSimpleStrategy.t.sol:RFPSimpleStrategyTest
// $ forge test --match-test "test_registrationIsBlockedWhenThePoolIsCreatedWithUseRegistryIsTrue" -vvv
//
    function test_registrationIsBlockedWhenThePoolIsCreatedWithUseRegistryIsTrue() public {
        // The registerRecipient() function does not work then the strategy was created using the
        // useRegistryAnchor = true.
        //
        bool useRegistryAnchorTrue = true;
        RFPSimpleStrategy custom_strategy = new RFPSimpleStrategy(address(allo()), "RFPSimpleStrategy");

        vm.prank(pool_admin());
        poolId = allo().createPoolWithCustomStrategy(
            poolProfile_id(),
            address(custom_strategy),
            abi.encode(maxBid, useRegistryAnchorTrue, metadataRequired),
            NATIVE,
            0,
            poolMetadata,
            pool_managers()
        );
        //
        // Create profile1 metadata and anchor
        Metadata memory metadata = Metadata({protocol: 1, pointer: "metadata"});
        address anchor = profile1_anchor();
        bytes memory data = abi.encode(anchor, 1e18, metadata);
        //
        // Profile1 member registers to the pool but it reverted by RECIPIENT_ERROR
        vm.startPrank(address(profile1_member1()));
        vm.expectRevert(abi.encodeWithSelector(RECIPIENT_ERROR.selector, address(anchor)));
        allo().registerRecipient(poolId, data);
    }
```

## Impact

The pool created with a strategy using the `userRegistryAnchor=true` can not get registrants because `_registerRecipient()` will be reverted all the time. If the pool is funded but no one can be allocated since [there is not registered recipients](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L397), the deposited funds by others may be trapped because those are not [distributed](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L429) since there are not `registrants`.


## Code Snippet

- [_registerRecipient()](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L314)

## Tool used

Manual review

## Recommendation

When the strategy is using `useRegistryAncho=true`, get the `recipientAddress` from the `data`:

```diff
    function _registerRecipient(bytes memory _data, address _sender)
        internal
        override
        onlyActivePool
        returns (address recipientId)
    {
        bool isUsingRegistryAnchor;
        address recipientAddress;
        address registryAnchor;
        uint256 proposalBid;
        Metadata memory metadata;

        // Decode '_data' depending on the 'useRegistryAnchor' flag
        if (useRegistryAnchor) {
            /// @custom:data when 'true' -> (address recipientId, uint256 proposalBid, Metadata metadata)
--          (recipientId, proposalBid, metadata) = abi.decode(_data, (address, uint256, Metadata));
++          (recipientId, recipientAddress, proposalBid, metadata) = abi.decode(_data, (address, address, uint256, Metadata));

            // If the sender is not a profile member this will revert
            if (!_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();
```

# Issue M-9: Can not create a pool by cloning strategies on zkSync network 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/411 

## Found by 
0xc0ffEE, imsrybr0

## Vulnerability Detail
When creating pool by cloning strategies, logics inside `Clone::createClone(address,uint256)` is executed, which calls to `ClonesUpgradeable::cloneDeterministic()`. Here, OpenZeppelin implements `ClonesUpgradeable::cloneDeterministic()` to deploy minimal proxy using almost assembly and using `create2`. 

So far, cloning a strategy using library `Clone` would get failed as [zksync docs pointed out](https://era.zksync.io/docs/reference/architecture/differences-with-ethereum.html#evm-instructions)

PoC:
[Check this deployed address on zksync era testnet](https://goerli.explorer.zksync.io/address/0xB1ae3211B3171a866bDCC2a69dA36448F594B9F6#contract). Try clone(), we would get failed

## Impact
Protocol does not work properly on zksync era: could not create pool by cloning strategies

## Code Snippet
https://github.com/allo-protocol/allo-v2/blob/851571c27df5c16f6586ece2a1cb6fd0acf04ec9/contracts/core/Allo.sol#L190
https://github.com/allo-protocol/allo-v2/blob/851571c27df5c16f6586ece2a1cb6fd0acf04ec9/contracts/core/libraries/Clone.sol#L26-L35

## Tool used

Manual Review

## Recommendation
Consider implementing different pattern for deploying/cloning strategies, such as: Using Factory for each kind of strategy and allow `Allo` contract to calls to Factory to deploy/clone strategies



## Discussion

**thelostone-mc**

This is understood. We are working with the zksync team to see when Clones would be supported and until then it is understood that the createPool function will not be usable and instead pool creators would have to rely on `createPoolWithCustomStartegy`

**codenamejason**

It doesn't look like they are going to support this any time soon https://github.com/zkSync-Community-Hub/zkync-developers/discussions/91 and https://github.com/zkSync-Community-Hub/zkync-developers/discussions/97



# Issue M-10: `QVSimpleStrategy`: If someone fund a pool when the fund is partially/fully distributed, part of the fund may be locked 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/446 

## Found by 
ast3ros, jkoppel, lemonmon, nobody2018, rvierdiiev
When `Allo::fundPool` is called when the funds are partially or fully distributed, the added funds may be locked.

## Vulnerability Detail

`Allo::fundPool` can be called by anyone at anytime, and it will increase the `BaseStrategy.poolAmount` via `BaseStrategy::increasePoolAmount()`.

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/core/Allo.sol#L339-L345

The `BaseStrategy.poolAmount` storage variable is used to determine the payout of each recipient by `QVBaseStrategy::_getPayout`:

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol#L559-L574


When the fund is distributed by the pool manager via `QVBaseStrategy::_distribute`, the `paidOut` flag for the recipientId whose share was distributed will be set to be true.

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol#L458

The problem occurs when some funds are  added when some funds are distributed.
In the case, the funds will be partially or fully locked.

## Impact

If some funds are added after the distribution is started, the added funds may be locked.

## Code Snippet

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/core/Allo.sol#L339-L345

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol#L559-L574


https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol#L458

## Tool used

Manual Review

## Recommendation

Consider adding recoverFund function like other strategies.
Alternatively, allow the `fundPool` function only before the distribution starts.

# Issue M-11: `_distribute()` function in RFPSimpleStrategy contract has wrong requirement causing DOS 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/492 

## Found by 
0xarno, 0xdeadbeef, 0xkaden, BenRai, GimelSec, HHK, KingNFT, WATCHPUG, ZdravkoHr., ace13567, alexxander, dany.armstrong90, fishgang, grearlake, honeymewn, jkoppel, lemonmon, nobody2018, osmanozdemir1, p0wd3r, pengun, pontifex, qbs, tnquanghuy0512
## Vulnerability Detail
The function `_distribute()`:
```solidity
    function _distribute(address[] memory, bytes memory, address _sender)
        internal
        virtual
        override
        onlyInactivePool
        onlyPoolManager(_sender)
    {
        ...

        IAllo.Pool memory pool = allo.getPool(poolId);
        Milestone storage milestone = milestones[upcomingMilestone];
        Recipient memory recipient = _recipients[acceptedRecipientId];

        if (recipient.proposalBid > poolAmount) revert NOT_ENOUGH_FUNDS();

        uint256 amount = (recipient.proposalBid * milestone.amountPercentage) / 1e18;

        poolAmount -= amount;//<@@ NOTICE the poolAmount get decrease over time

        _transferAmount(pool.token, recipient.recipientAddress, amount);

        ...
    }
```

Let's suppose this scenario:
 - Pool manager funding the contract with 100 token, making `poolAmount` variable equal to 100
 - Pool manager set 5 equal milestones with 20% each
 - Selected recipient's proposal bid is 100, making `recipients[acceptedRecipientId].proposalBid` variable equal to 100
 - After milestone 1 done, pool manager pays recipient using `distribute()`. Value of variables after:  `poolAmount = 80 ,recipients[acceptedRecipientId].proposalBid = 100`
 - After milestone 2 done, pool manager will get DOS trying to pay recipient using `distribute()` because of this line:
 ```solidity
if (recipient.proposalBid > poolAmount) revert NOT_ENOUGH_FUNDS();
```
## Impact
This behaviour will cause DOS when distributing the 2nd milestone or higher
## Code Snippet
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/6430c8004017e96ae2f5aac365bdefd0b6eeea72/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L417C1-L450C6
## Tool used

Manual Review

## Recommendation
```solidity
-        if (recipient.proposalBid > poolAmount) revert NOT_ENOUGH_FUNDS();
+        if ((recipient.proposalBid * milestone.amountPercentage) / 1e18 > poolAmount) revert NOT_ENOUGH_FUNDS();
```

# Issue M-12: ````reviewRecipients()```` might rollback recipients' new applications 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/569 

## Found by 
KingNFT, jovi

## Vulnerability Detail
Let's look at the implementation of ````reviewRecipients()````, ````statusesBitMap```` is updated with ````fullRow```` without checking data freshness.
```solidity
File: contracts\strategies\donation-voting-merkle-base\DonationVotingMerkleDistributionBaseStrategy.sol
341:     function reviewRecipients(ApplicationStatus[] memory statuses)
342:         external
343:         onlyActiveRegistration
344:         onlyPoolManager(msg.sender)
345:     {
346:         // Loop through the statuses and set the status
347:         for (uint256 i; i < statuses.length;) {
348:             uint256 rowIndex = statuses[i].index;
349:             uint256 fullRow = statuses[i].statusRow;
350: 
351:             statusesBitMap[rowIndex] = fullRow;
352: 
353:             // Emit that the recipient status has been updated with the values
354:             emit RecipientStatusUpdated(rowIndex, fullRow, msg.sender);
355: 
356:             unchecked {
357:                 i++;
358:             }
359:         }
360:     }


```

Now, let's consider the case below:
_for simplicity, let a ````fullRow=0xABCD```` represents 4 recipients' status, 4 bits per recipient._
(1) pool manager begins to review applications and there are two pending applications, the initial states are
```solidity
block.timestamp = 100
fullRow = 0x0011
```

(2) a third recipient's application initiated, but doesn't mined
```solidity
block.timestamp = 195
fullRow = 0x0011
```
(3) the pool manager approves the first two applications, initiate a transaction with new ````fullRow = 0x0022````
```solidity
block.timestamp = 200
fullRow = 0x0011
```

(4) the third recipient's application transaction mined
```solidity
block.timestamp = 205
fullRow = 0x0111
```

(5) the pool manager's approval transaction mined
```solidity
block.timestamp = 210
fullRow = 0x0022
```
We can see the third application's status is overwritten from ````Status.Pending(1)```` to ````Status.None(0)```` .

## Impact
(1) recipients' applications might be rolled back
(2) updates from other pool managers might also be overwritten.

## Code Snippet
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L341

## Tool used

Manual Review

## Recommendation
P.S. this solution is easy but can't address the conflicts between pool managers.
```diff
File: contracts\strategies\donation-voting-merkle-base\DonationVotingMerkleDistributionBaseStrategy.sol
-341:     function reviewRecipients(ApplicationStatus[] memory statuses)
+341:     function reviewRecipients(ApplicationStatus[] memory statuses, uint256 refRecipientsCounter)
342:         external
343:         onlyActiveRegistration
344:         onlyPoolManager(msg.sender)
345:     {
+            if (refRecipientsCounter != recipientsCounter) revert STATUSES_OUTDATED();
346:         // Loop through the statuses and set the status
347:         for (uint256 i; i < statuses.length;) {
348:             uint256 rowIndex = statuses[i].index;
349:             uint256 fullRow = statuses[i].statusRow;
350: 
351:             statusesBitMap[rowIndex] = fullRow;
352: 
353:             // Emit that the recipient status has been updated with the values
354:             emit RecipientStatusUpdated(rowIndex, fullRow, msg.sender);
355: 
356:             unchecked {
357:                 i++;
358:             }
359:         }
360:     }


```

# Issue M-13: In `QVBaseStrategy` the same manager can review one applicant multiple times and thereby render the safety measure of `reviewThreshold` useless 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/589 

## Found by 
0xarno, 0xkaden, 0xpoolbaer, BenRai, KingNFT, Silvermist, WATCHPUG, ZdravkoHr., ace13567, al88nsk, fibonacci, gkrastenov, jkoppel, osmanozdemir1, pengun, tnquanghuy0512, xAriextz, yegorre

## Vulnerability Detail

In `QVBaseStrategy` to ensure additional safety, multiple poolManagers need to review one applicant before he can be accepted. The number of revies to a particular recommendation (accepted or rejected ) must be equal or exceed the set `reviewThreshold`. This safeguard it in place to make sure that multiple poolManager take a look at the same recipient. The problem arises from the fact that it is not tracked if a manager already reviewed the recipient or not. This can lead to the situation where the same manager reviews one recipient multiple times and the recipient is thereby accepted or rejected even though not the required number of poolManagers have revied the recipient.

Example:

The `reviewThreshold` for a `QVBaseStrategy` is set to 2. Alice, a pool manager, reviews one batch of recipients and reviews Bob, a potential recipient, as accepted. When reviewing a second batch of recipients she accidently adds the review of Bob to the data again and reviews Bob as accepted again. Now Bob was accepted even though only one poolManager reviewed him an not the recommended two.


## Impact
Recipients are accepted/rejected even though they have not been reviewed by the recommended number of poolManagern

## Code Snippet

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/6430c8004017e96ae2f5aac365bdefd0b6eeea72/allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol#L254-L288

## Tool used

Manual Review

## Recommendation

Track who revied which applicant to make sure that no poolManager reviews an applicant multiple times and thereby bypasses the safety guard of the `reviewThreshold`



## Discussion

**thelostone-mc**

Review threshold doesn't make a lot of sense for QV at this point. Will have to discuss this internally but regardless a fix is needed for this

# Issue M-14: `QVBaseStrategy::reviewRecipients()` doesn't check if the recipient is already accepted or rejected, and overwrites the current status 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/699 

## Found by 
0x00ffDa, BenRai, gkrastenov, osmanozdemir1, xAriextz

## Vulnerability Detail
In the QV strategy contracts, recipients register themselves and wait for a pool manager to accept the registration. Pool managers can accept or reject recipients with the `reviewRecipients()` function. There is also a threshold (`reviewThreshold`) for recipients to be accepted. For example, if the `reviewThreshold` is 2, a pending recipient gets accepted when two managers accept this recipient and the `recipientStatus` is updated.

However, `QVBaseStrategy::reviewRecipients()` function doesn't check the recipient's current status. This one alone may not be an issue because managers may want to change the status of the recipient etc.  
But on top of that, the function also doesn't take the previous review counts into account when updating the status, and overwrites the status immediately after reaching the threshold. I'll share a scenario later about this below.

Here is the `reviewRecipients()` function:  
[https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol#L254C1-L288C6](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol#L254C1-L288C6)

```solidity
file: QVBaseStrategy.sol
    function reviewRecipients(address[] calldata _recipientIds, Status[] calldata _recipientStatuses)
        external
        virtual
        onlyPoolManager(msg.sender)
        onlyActiveRegistration
    {
        // make sure the arrays are the same length
        uint256 recipientLength = _recipientIds.length;
        if (recipientLength != _recipientStatuses.length) revert INVALID();

        for (uint256 i; i < recipientLength;) {
            Status recipientStatus = _recipientStatuses[i];
            address recipientId = _recipientIds[i];

            // if the status is none or appealed then revert
            if (recipientStatus == Status.None || recipientStatus == Status.Appealed) { //@audit these are the input parameter statuse not the recipient's status.
                revert RECIPIENT_ERROR(recipientId);
            }

            reviewsByStatus[recipientId][recipientStatus]++;

 -->        if (reviewsByStatus[recipientId][recipientStatus] >= reviewThreshold) { //@audit recipientStatus is updated right after the threshold is reached. It can overwrite if the status is already set.
                Recipient storage recipient = recipients[recipientId];
                recipient.recipientStatus = recipientStatus;

                emit RecipientStatusUpdated(recipientId, recipientStatus, address(0));
            }

            emit Reviewed(recipientId, recipientStatus, msg.sender);

            unchecked {
                ++i;
            }
        }
    }
```

As I mentioned above, the function updates the `recipientStatus` immediately after reaching the threshold. Here is a scenario of why this might be an issue.

**Example Scenario**  
The pool has 5 managers and the `reviewThreshold` is 2.

1. The first manager rejects the recipient
    
2. The second manager accepts the recipient
    
3. The third manager rejects the recipient. -&gt; `recipientStatus` updated -&gt; `status = REJECTED`
    
4. The fourth manager rejects the recipient -&gt; status still `REJECTED`
    
5. The last manager accepts the recipient -&gt;`recipientStatus` updated again -&gt; `status = ACCEPTED`
    

*3 managers rejected and 2 managers accepted the recipient but the recipient status is overwritten without checking the recipient's previous status and is ACCEPTED now.*

## Coded PoC

You can prove the scenario above with the PoC. You can use the protocol's own setup for this.  
\- Copy the snippet below and paste it into the `QVBaseStrategy.t.sol` test file.  
\- Run forge test `--match-test test_reviewRecipient_reviewTreshold_OverwriteTheLastOne`

```solidity
//@audit More managers rejected but the recipient is accepted
    function test_reviewRecipient_reviewTreshold_OverwriteTheLastOne() public virtual {
        address recipientId = __register_recipient();

        // Create rejection status
        address[] memory recipientIds = new address[](1);
        recipientIds[0] = recipientId;
        IStrategy.Status[] memory Statuses = new IStrategy.Status[](1);
        Statuses[0] = IStrategy.Status.Rejected;

        // Reject three times with different managers
        vm.startPrank(pool_manager1());
        qvStrategy().reviewRecipients(recipientIds, Statuses);

        vm.startPrank(pool_manager2());
        qvStrategy().reviewRecipients(recipientIds, Statuses);

        vm.startPrank(pool_manager3());
        qvStrategy().reviewRecipients(recipientIds, Statuses);

        // Three managers rejected. Status will be rejected.
        assertEq(uint8(qvStrategy().getRecipientStatus(recipientId)), uint8(IStrategy.Status.Rejected));
        assertEq(qvStrategy().reviewsByStatus(recipientId, IStrategy.Status.Rejected), 3);

        // Accept two times after three rejections
        Statuses[0] = IStrategy.Status.Accepted;
        vm.startPrank(pool_admin());
        qvStrategy().reviewRecipients(recipientIds, Statuses);

        vm.startPrank(pool_manager4());
        qvStrategy().reviewRecipients(recipientIds, Statuses);

        // 3 Rejected, 2 Accepted, but status is Accepted because it overwrites right after passing threshold.
        assertEq(uint8(qvStrategy().getRecipientStatus(recipientId)), uint8(IStrategy.Status.Accepted));
        assertEq(qvStrategy().reviewsByStatus(recipientId, IStrategy.Status.Rejected), 3);
        assertEq(qvStrategy().reviewsByStatus(recipientId, IStrategy.Status.Accepted), 2);
    }
```

You can find the test results below:

```solidity
Running 1 test for test/foundry/strategies/QVSimpleStrategy.t.sol:QVSimpleStrategyTest
[PASS] test_reviewRecipient_reviewTreshold_OverwriteTheLastOne() (gas: 249604)
Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 10.92ms
```

## Impact
Recipient status might be overwritten with less review counts.

## Code Snippet
[https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol#L254C1-L288C6](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol#L254C1-L288C6)

```solidity
file: QVBaseStrategy.sol
    function reviewRecipients(address[] calldata _recipientIds, Status[] calldata _recipientStatuses)
        external
        virtual
        onlyPoolManager(msg.sender)
        onlyActiveRegistration
    {
        // make sure the arrays are the same length
        uint256 recipientLength = _recipientIds.length;
        if (recipientLength != _recipientStatuses.length) revert INVALID();

        for (uint256 i; i < recipientLength;) {
            Status recipientStatus = _recipientStatuses[i];
            address recipientId = _recipientIds[i];

            // if the status is none or appealed then revert
            if (recipientStatus == Status.None || recipientStatus == Status.Appealed) { //@audit these are the input parameter statuse not the recipient's status.
                revert RECIPIENT_ERROR(recipientId);
            }

            reviewsByStatus[recipientId][recipientStatus]++;

 -->        if (reviewsByStatus[recipientId][recipientStatus] >= reviewThreshold) { //@audit recipientStatus is updated right after the threshold is reached. It can overwrite if the status is already set.
                Recipient storage recipient = recipients[recipientId];
                recipient.recipientStatus = recipientStatus;

                emit RecipientStatusUpdated(recipientId, recipientStatus, address(0));
            }

            emit Reviewed(recipientId, recipientStatus, msg.sender);

            unchecked {
                ++i;
            }
        }
    }
```

## Tool used

Manual Review

## Recommendation
Checking the review counts before updating the state might be helpful to mitigate this issue



## Discussion

**0xKurt**

@nfrgosselin 
How to deal with this depends of how the pool admin wants to approve or reject applications:

1. Count each status --> 4 accepted and 2 rejected with threshold at 8 this would be approved
2. Whatever the last status set is --> the last manager to set the status
3. Once the status is set it cannot be changed

These are a couple example we thought of. WDYT?

# Issue M-15: M-04 Funds can be locked in the DonationVotingMerkleDistributionBaseStrategy due to having a receive payable function and the unique functionality of the withdraw function. 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/719 

## Found by 
BenRai, imare, parsely
## Impact
Funds sent into the contract using the `receive` function, or other ERC20 tokens not of the `pool.token`  can remain locked in the contract.

## Vulnerability Detail
The internal accounting uses the `poolAmount` variable to keep track of the balances.

The receive function does not increment the `poolAmount` variable when funds are received, this in itself is not an issue as the contract token may not be the `NATIVE` token.

Two scenarios arise from this situation.
The first being that if the `pool.token` is ETH, the actual balance of the contract and the internal accounting can differ significantly.
The second aspect to keep in mind is that, should the `pool.token` not be ETH, the `poolAmount` variable is tracking the balance of the `pool.token`, and there is no mechanism to keep track of ETH funds that may be sent into the contract using the `receive` function.

In the first scenario the values would be misaligned leaving the funds locked in the contract and in the second scenario, the `NATIVE`(ETH) funds could never be withdrawn as the `withdraw` function uses the `pool.token` to decide what type of transfer to action.

Scenario1 (pool token is ETH):
1. The `poolAmount` is 1 ETH.
2. 10 ETH is sent in using the `receive` function.
3. The actual balance is now 11 ETH.
4. The pool admin withdraws 1 ETH.
5. The internal accounting decrements `poolAmount` to be ZERO.
6. The actual balance is now 10 ETH
7. The funds are locked because the withdraw function will revert due to any value sent into the withdraw function being greater the `poolAmount` (ZERO) as in the check below.
```solidity
if (_amount > poolAmount) {
            revert INVALID();
        }
```

Scenario2 (pool token is USDC):
1. The `poolAmount` is 1 USDC.
2. 10 ETH is sent in using the `receive` function.
3. The actual balance is now 1O ETH and 1 USDC.
4. The pool admin withdraws 1 USDC.
5. The internal accounting decrements `poolAmount` to be ZERO.
6. The actual balance is still 10 ETH
7. The funds are locked because the withdraw function will revert due to any value sent into the withdraw function being greater the `poolAmount` (ZERO) as in the check below.
```solidity
if (_amount > poolAmount) {
            revert INVALID();
        }
```

## Code Snippet
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L394-L409

A similar scenario can be found in RFPSimpleStrategy.sol.

```solidity
    function withdraw(uint256 _amount) external onlyPoolManager(msg.sender) {
        if (block.timestamp <= allocationEndTime + 30 days) {
            revert INVALID();
        }

        IAllo.Pool memory pool = allo.getPool(poolId);

        if (_amount > poolAmount) {
            revert INVALID();
        }

        poolAmount -= _amount;

        // Transfer the tokens to the 'msg.sender' (pool manager calling function)
        _transferAmount(pool.token, msg.sender, _amount);
    }
```



## PoC
Copy/Paste this test function in the `DonationVotingMerkleDistributionBase.t.sol` file in the `test/foundry/strategies/` directory:
```solidity
function test_depositAndWithdraw() public {
        address tester = makeAddr("tester");
        vm.deal(tester, 100 ether);
        vm.startPrank(tester);
        console.log("[+] The strategy poolAmount variable value before deposit is : ",strategy.getPoolAmount());
        console.log("[+] The balance of the strategy contract before the call is : ",address(strategy).balance);
        console.log("[+] Now depositing 10 ETH");
        address(strategy).call{value: 10 ether}("");
        console.log("[+] The strategy poolAmount variable value after deposit is : ",strategy.getPoolAmount());
        console.log("[+] The balance of the strategy contract after the call is : ",address(strategy).balance);
        vm.stopPrank();
        vm.warp(block.timestamp + 90 days);
        console.log("[+] Now withdrawing 1 ETH");
        vm.startPrank(pool_admin());
        strategy.withdraw(1 ether);
        vm.stopPrank();
        console.log("[+] The strategy poolAmount variable value after withdrawal is : ",strategy.getPoolAmount());
        console.log("[+] The balance of the strategy contract after withdrawal is : ",address(strategy).balance);
        console.log("[+] There is still 10 ETH of funds to withdraw but the internal accounting shows ZERO");
        console.log("[+] Try withdrawing 1 ETH");
        console.log("[+] We are expecting a revert");
        vm.startPrank(pool_admin());
        vm.expectRevert();
        strategy.withdraw(1 ether);
        vm.stopPrank();
    }
```
## Output
```text
[PASS] test_depositAndWithdraw() (gas: 109514)
Logs:
  [+] The strategy poolAmount variable value before deposit is :  1000000000000000000
  [+] The balance of the strategy contract before the call is :  1000000000000000000
  [+] Now depositing 10 ETH
  [+] The strategy poolAmount variable value after deposit is :  1000000000000000000
  [+] The balance of the strategy contract after the call is :  11000000000000000000
  [+] Now withdrawing 1 ETH
  [+] The strategy poolAmount variable value after withdrawal is :  0
  [+] The balance of the strategy contract after withdrawal is :  10000000000000000000
  [+] There is still 10 ETH of funds to withdraw but the internal accounting shows ZERO
  [+] Try withdrawing 1 ETH
  [+] We are expecting a revert

Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 9.60ms
 
Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)
```
Run forge test 
```text
forge test --match-contract DonationVotingMerkleDistributionBaseMockTest --match-test test_depositAndWithdraw -vv
```
## Tool used

Manual Review

## Recommendation
Two possibilities could be considered.
1. Modify the withdraw function to work with the actual balance of the contract based on the token that is required to be withdrawn, and allow the caller to specify the token.
2. Increment the `poolAmount` on receiving funds via the `receive` function.

The second option would only work if the token would always be the `NATIVE` token, therefore it would be preferable to alter the withdraw function or implement a separate `sweep` function.



## Discussion

**thelostone-mc**

The intention here was to ensure only funds can be moved into the strategy via allo's fundPool
We could update withdraw to revert when `msg.sender` is not Allo but this works only for native tokens.

In both the scenarios, the pool manager tries to send funds to the contract bypassing the fees. Implementing a sweep function might be worthy but we'd have to figure who has the permission to do that

**0xKurt**

i would suggest to introduce a recoverFunds function. Therefore we need to track (on the Vault version) the total amounts of each token.

the poolAmount shouldn't be updated when funds are directly sent to the contract

# Issue M-16: `QVBaseStrategy` contract : recipient `reviewStatus` is not reset upon re-registration 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/729 

## Found by 
ArmedGoose, WATCHPUG, ast3ros, hals, honeymewn
`QVBaseStrategy` contract : the reviewStatus of the recipient is not reset (set to zero) when he re-registres again.

## Vulnerability Detail

- In `QVBaseStrategy` strategy contract: when the user first registers; his status is updated from `None` to `Pending`.

- Then the pool manager can review recipients (via `reviewRecipients` function) and update their statuses from `Pending` to `Accepted` and from `Accepted` to `Pending` only (not updating to `Rejected` or `Appealed`) if these recipients statuses got votes equal to `reviewThreshold`:

  [QVBaseStrategy::reviewRecipients /L275-280](https://github.com/allo-protocol/allo-v2/blob/0b881ef4a0013d2809374c9ea69f4cf1288dfe62/contracts/strategies/qv-base/QVBaseStrategy.sol#L275-L280)

  ```solidity
              if (reviewsByStatus[recipientId][recipientStatus] >= reviewThreshold) {
                  Recipient storage recipient = recipients[recipientId];
                  recipient.recipientStatus = recipientStatus;

                  emit RecipientStatusUpdated(recipientId, recipientStatus, address(0));
              }
  ```

- The strategy contract allows registered recipients to re-register again with new terms; and when doing so, their statuses are updated from `Accepted` ==> `Pending` or from `Rejected` to `Appealed`:

  [QVBaseStrategy::\_registerRecipient /L275-280](https://github.com/allo-protocol/allo-v2/blob/0b881ef4a0013d2809374c9ea69f4cf1288dfe62/contracts/strategies/qv-base/QVBaseStrategy.sol#L414-L429)

  ```solidity
  if (currentStatus == Status.None) {
            // recipient registering new application
            recipient.recipientStatus = Status.Pending;
            emit Registered(recipientId, _data, _sender);
        } else {
            if (currentStatus == Status.Accepted) {
                // recipient updating accepted application
                recipient.recipientStatus = Status.Pending;
            } else if (currentStatus == Status.Rejected) {
                // recipient updating rejected application
                recipient.recipientStatus = Status.Appealed;
            }

            // emit the new status with the '_data' that was passed in
            emit UpdatedRegistration(recipientId, _data, _sender, recipient.recipientStatus);
        }
  ```

## Impact

But as can be noticed; the reviewRecipient status of the re-registered recipient is not reset which will result in this re-registered recipient getting `Accepted` status on their new registration in the next review round/rounds with lesser votes to reach `reviewThreshold`.

## Code Snippet

[QVBaseStrategy::\_registerRecipient /L275-280](https://github.com/allo-protocol/allo-v2/blob/0b881ef4a0013d2809374c9ea69f4cf1288dfe62/contracts/strategies/qv-base/QVBaseStrategy.sol#L414-L429)

```solidity
if (currentStatus == Status.None) {
          // recipient registering new application
          recipient.recipientStatus = Status.Pending;
          emit Registered(recipientId, _data, _sender);
      } else {
          if (currentStatus == Status.Accepted) {
              // recipient updating accepted application
              recipient.recipientStatus = Status.Pending;
          } else if (currentStatus == Status.Rejected) {
              // recipient updating rejected application
              recipient.recipientStatus = Status.Appealed;
          }

          // emit the new status with the '_data' that was passed in
          emit UpdatedRegistration(recipientId, _data, _sender, recipient.recipientStatus);
      }
```

[QVBaseStrategy::reviewRecipients ](https://github.com/allo-protocol/allo-v2/blob/0b881ef4a0013d2809374c9ea69f4cf1288dfe62/contracts/strategies/qv-base/QVBaseStrategy.sol#L254-L288)

```solidity
  function reviewRecipients(address[] calldata _recipientIds, Status[] calldata _recipientStatuses)
      external
      virtual
      onlyPoolManager(msg.sender)
      onlyActiveRegistration
  {
      // make sure the arrays are the same length
      uint256 recipientLength = _recipientIds.length;
      if (recipientLength != _recipientStatuses.length) revert INVALID();

      for (uint256 i; i < recipientLength;) {
          Status recipientStatus = _recipientStatuses[i];
          address recipientId = _recipientIds[i];

          // if the status is none or appealed then revert
          if (recipientStatus == Status.None || recipientStatus == Status.Appealed) {
              revert RECIPIENT_ERROR(recipientId);
          }

          reviewsByStatus[recipientId][recipientStatus]++;

          if (reviewsByStatus[recipientId][recipientStatus] >= reviewThreshold) {
              Recipient storage recipient = recipients[recipientId];
              recipient.recipientStatus = recipientStatus;

              emit RecipientStatusUpdated(recipientId, recipientStatus, address(0));
          }

          emit Reviewed(recipientId, recipientStatus, msg.sender);

          unchecked {
              ++i;
          }
      }
  }
```

## Tool used

Manual Review

## Recommendation

Update `_registerRecipient` function to reset `reviewsByStatus[recipientId][recipientStatus]` when the recipient re-registers:

```diff
if (currentStatus == Status.None) {
          // recipient registering new application
          recipient.recipientStatus = Status.Pending;
          emit Registered(recipientId, _data, _sender);
      } else {
          if (currentStatus == Status.Accepted) {
              // recipient updating accepted application
              recipient.recipientStatus = Status.Pending;
+             reviewsByStatus[recipientId][Status.Accepted]=0;
          } else if (currentStatus == Status.Rejected) {
              // recipient updating rejected application
              recipient.recipientStatus = Status.Appealed;
          }

          // emit the new status with the '_data' that was passed in
          emit UpdatedRegistration(recipientId, _data, _sender, recipient.recipientStatus);
      }
```



## Discussion

**codenamejason**

A related issue -> https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/699

# Issue M-17: When ```block.timestamp == allocationEndTime``` this can bypassed both ```onlyActiveAllocation()``` and ```onlyAfterAllocation()``` modifiers. 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/839 

## Found by 
dopeflamingo, gkrastenov, jkoppel, p0wd3r, shirochan

## Vulnerability Detail
The distribute based functions should only be called after all the allocation has taken place and the allocate functions should only be called during active allocation times, however this specific condition at  ```block.timestamp == allocationEndTime``` has left it so that both functions can be called at the same time. 

## Impact
This could lead to a distribution function being called before an allocation has taken place which seems to be unwanted behaviour for this protocol.

## Code Snippet

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L465-L469

https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L473-L476

These modifiers are also used in QVBaseStrategy.sol.

## Tool used

Manual Review

## Recommendation

I would recommend that the protocol make it so that the ```_checkOnlyAfterAllocation()``` function reverts at the time ```block.timestamp == allocationEndTime```. 

Change the if statement from ```if (block.timestamp < allocationEndTime)``` to:

```if (block.timestamp <= allocationEndTime)``` so that it is strictly only after the allocation period has ended.

# Issue M-18: CREATE3 is not available in the zkSync Era. 

Source: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/862 

## Found by 
0xc0ffEE, 0xnirlin, carrotsmuggler, imsrybr0, jkoppel, pengun

## Vulnerability Detail
According to the contest README, the project can be deployed in zkSync Era. (https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/README.md?plain=1#L11)

The zkSync Era docs explain how it differs from Ethereum.

The description of CREATE and CREATE2 (https://era.zksync.io/docs/reference/architecture/differences-with-ethereum.html#create-create2) states that Create cannot be used for arbitrary code unknown to the compiler.

POC: 
```solidity
// SPDX-License-Identifier: Unlicensed
pragma solidity ^0.8.0;

import "./MiniContract.sol";
import "./CREATE3.sol";

contract DeployTest {
    address public deployedAddress;
    event Deployed(address);
    
    function generateContract() public returns(address, address) {
        bytes32 salt = keccak256("SALT");

        address preCalculatedAddress = CREATE3.getDeployed(salt);

        // check if the contract has already been deployed by checking code size of address
        bytes memory creationCode = abi.encodePacked(type(MiniContract).creationCode, abi.encode(777));

        // Use CREATE3 to deploy the anchor contract
        address deployed = CREATE3.deploy(salt, creationCode, 0);
        return (preCalculatedAddress, deployed);
    }
}
```
You can check sample POC code at zkSync Era Testnet(https://goerli.explorer.zksync.io/address/0x0f670f8AfcB09f4BC509Cb59D6e7CEC1A52BFA51#contract)

Also, the logic to compute the address of Create2 is different from Ethereum, as shown below, so the CREATE3 library cannot be used as it is.

This cause registry returns an incorrect `preCalculatedAddress`, causing the anchor to be registered to an address that is not the actual deployed address.

```solidity 
address ⇒ keccak256( 
    keccak256("zksyncCreate2") ⇒ 0x2020dba91b30cc0006188af794c2fb30dd8520db7e2c088b7fc7c103c00ca494, 
    sender, 
    salt, 
    keccak256(bytecode), 
    keccak256(constructorInput)
 ) 
```



## Impact
`generateAnchor` doesn't work, so user can't do anything related to anchor.

## Code Snippet
https://github.com/allo-protocol/allo-v2/blob/851571c27df5c16f6586ece2a1cb6fd0acf04ec9/contracts/core/Registry.sol#L350
https://github.com/allo-protocol/allo-v2/blob/851571c27df5c16f6586ece2a1cb6fd0acf04ec9/contracts/core/Registry.sol#L338
## Tool used

Manual Review

## Recommendation
This can be solved by implementing CREATE2 directly instead of CREATE3 and using `type(Anchor).creationCode`.
Also, the compute address logic needs to be modified for zkSync.


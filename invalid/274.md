Little Cloth Coyote

high

# Pool Committees Unable to Allocate or Vote on Beyond First Milestone
Pool committees face a constraint where they can only allocate funds for the first upcoming milestone. After the completion of first milestone and the distribution of funds, committees are unable to allocate or vote on subsequent milestones. 

## Vulnerability Detail
Pool committees encounter a limitation in the `allocate()` function, which restricts their ability to allocate funds for the next `upcomingMilestone` once the first one is completed. Let's take a look at `_distribute()`, where first `upcomingMilestone` is completed and incremented.
```solidity
    function _distribute(address[] memory, bytes memory, address _sender)
        internal
        virtual
        override
        onlyInactivePool
        onlyPoolManager(_sender)
    {
        // check to make sure there is a pending milestone
        if (upcomingMilestone >= milestones.length) revert INVALID_MILESTONE();

        IAllo.Pool memory pool = allo.getPool(poolId);
        Milestone storage milestone = milestones[upcomingMilestone];
        Recipient memory recipient = _recipients[acceptedRecipientId];

        // make sure has enough funds to distribute based on the proposal bid
        if (recipient.proposalBid > poolAmount) revert NOT_ENOUGH_FUNDS();

        // Calculate the amount to be distributed for the milestone
        uint256 amount = (recipient.proposalBid * milestone.amountPercentage) / 1e18;

        // Get the pool, subtract the amount and transfer to the recipient
        poolAmount -= amount;
        _transferAmount(pool.token, recipient.recipientAddress, amount);

        // Set the milestone status to 'Accepted'
        milestone.milestoneStatus = Status.Accepted;

        // Increment the upcoming milestone
        upcomingMilestone++;

        // Emit events for the milestone and the distribution
        emit MilestoneStatusChanged(upcomingMilestone, Status.Accepted);
        emit Distributed(acceptedRecipientId, recipient.recipientAddress, amount, _sender);
    }
```
The issue arises because the `acceptedRecipientId` state variable still reflects the last recipient and was never reset to address(0) again. The current implementation of `_allocate()` will trigger a revert when `acceptedRecipientId != address(0)`, making it impossible to process committee votes for subsequent milestones.
```solidity
    function _allocate(bytes memory _data, address _sender) internal override onlyPoolManager(_sender) {
        if (acceptedRecipientId != address(0)) {
            revert RECIPIENT_ALREADY_ACCEPTED();
        }

        // Check if the allocator has already casted the vote
        address voteCastedTo = votedFor[_sender];
        if (voteCastedTo != address(0)) {
            // remove the old vote to allow recasting of vote
            votes[voteCastedTo] -= 1;
        }

        // Decode the '_data'
        address recipientId = abi.decode(_data, (address));

        // Increment the votes for the recipient
        votes[recipientId] += 1;
        // Update the votedFor mapping
        votedFor[_sender] = recipientId;

        // Emit the event
        emit Voted(recipientId, _sender);

        // Check if the recipient has reached the vote threshold
        if (votes[recipientId] == voteThreshold) {
            // Set the accepted recipient
            acceptedRecipientId = recipientId;

            Recipient storage recipient = _recipients[acceptedRecipientId];
            recipient.recipientStatus = Status.Accepted;

            // Set the pool to inactive
            _setPoolActive(false);

            emit Allocated(acceptedRecipientId, recipient.proposalBid, allo.getPool(poolId).token, address(0));
        }
    }
```

## Impact
Committees unable to allocate/vote beyond the first mile stone.
## Code Snippet
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-committee/RFPCommitteeStrategy.sol#L102
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L417
## Tool used

Manual Review

## Recommendation
I recommend removing the if block and adding onlyActivePool modifier.
```solidity
-    function _allocate(bytes memory _data, address _sender) internal override onlyPoolManager(_sender) {
+    function _allocate(bytes memory _data, address _sender) internal override onlyActivePool onlyPoolManager(_sender) {
-       if (acceptedRecipientId != address(0)) {
-           revert RECIPIENT_ALREADY_ACCEPTED();
-       }

        // Check if the allocator has already casted the vote
        address voteCastedTo = votedFor[_sender];
        if (voteCastedTo != address(0)) {
            // remove the old vote to allow recasting of vote
            votes[voteCastedTo] -= 1;
        }

        // Decode the '_data'
        address recipientId = abi.decode(_data, (address));

        // Increment the votes for the recipient
        votes[recipientId] += 1;
        // Update the votedFor mapping
        votedFor[_sender] = recipientId;

        // Emit the event
        emit Voted(recipientId, _sender);

        // Check if the recipient has reached the vote threshold
        if (votes[recipientId] == voteThreshold) {
            // Set the accepted recipient
            acceptedRecipientId = recipientId;

            Recipient storage recipient = _recipients[acceptedRecipientId];
            recipient.recipientStatus = Status.Accepted;

            // Set the pool to inactive
            _setPoolActive(false);

            emit Allocated(acceptedRecipientId, recipient.proposalBid, allo.getPool(poolId).token, address(0));
        }
    }
```
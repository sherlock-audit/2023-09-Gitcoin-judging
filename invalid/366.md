Decent Brunette Aphid

medium

# The owner can recover funds even when changing Anchor
When `updateProfile()` is called, a new `Anchor.sol` has been implemented for a new name and the owner can return to the previous Anchor; however, the owner still has access to the funds when the `Anchor.sol` is changed.


## Vulnerability Detail

When you use `Registry.updateName()`, the Allo protocol wants the owner to lose the reputation gained from your previous legitimate project.

They want the anchor to be attached to the profile so that when a name change is made, the previous anchors cannot be used as long as it is not the anchor that is attached to the profile.

Therefore, the owner cannot recover the anchor funds when he exchanges the anchor for a new one. But as we will see in the test, this is not true, since even when the name is changed and the profile changes to the new `Anchor.sol`.

 The owner can still successfully call the `execute()` function for all previous anchor deployed.

Since there is no verification that confirms that it is the Anchor that is active and that it is the only one for the profile at that moment.

```solidity
pragma solidity 0.8.19;

import "forge-std/Test.sol";
import {Anchor} from "../../../contracts/core/Anchor.sol";
import {Registry} from "../../../contracts/core/Registry.sol";
import {Metadata} from "../../../contracts/core/libraries/Metadata.sol";
import {IRegistry} from "../../../contracts/core/interfaces/IRegistry.sol";


contract AttackRegistryT is Test {
    Anchor public anchor;
    Registry public registry;

    address payable bob = payable(makeAddr("bob"));
    address payable alice = payable(makeAddr("alice"));

    function setUp() public {
        registry = new Registry();
        registry.initialize(msg.sender);
    }
    
    function test_getFundTheOldAnchor() public {
        vm.deal(bob,1000 ether);
        vm.startPrank(bob);
        Metadata memory metadata = Metadata({protocol: 1, pointer: "test metadata"});
        address[] memory emptyArray = new address[](0);
        // Create a profile
        bytes32 profileId = registry.createProfile(0,"test", metadata,address(bob),emptyArray);
        Registry.Profile memory profile = registry.getProfileById(profileId);
        address payable anchorAddress = payable(profile.anchor);      
        anchor = Anchor(anchorAddress);

        // Alice send fund to Anchor 1
        vm.deal(alice,10 ether);
        vm.startPrank(alice);
        uint256 balanceBefore = address(anchorAddress).balance;
        (bool success, ) = payable(anchorAddress).call{value: 1 ether}("");
        require(success);
        uint256 balanceAfter = address(anchorAddress).balance;
        assertEq(balanceBefore + 1 ether, balanceAfter);
        
        // Bod (Owner) try to change the name
        vm.startPrank(bob);
        // New anchor was created (Anchor 2)
        address newAnchor = registry.updateProfileName(profileId,"test 2");
        // Anchor's address are differents
        assertTrue(anchorAddress!=newAnchor);
        
       // Set correct registry
        anchor.setRegistry(address(registry));
        // Call execute() Anchor 1
        anchor.execute(address(payable(bob)),1 ether, "");
        // Check the Anchor 1 have dont funds
        balanceAfter = address(anchorAddress).balance;
        assertEq(0, balanceAfter);
        assertEq(0,address(anchor).balance);

    }

```
Note: if you want to run this test, you have to add the lines of code for a correct implementation of the `registry`: 
```solidity
    function setRegistry(address registryAddress) public {
        registry = Registry(registryAddress);
    }
```
_Anchor.sol_
This function is not recommended for use in production, it is only for testing purposes.

## Impact

The Allo protocol wants the anchor to be connected to the profile when it is active, but there is no variable that determines that a single Anchor for a profile is active, all anchors generated by the owner will always be active.

Therefore, the owner can recover funds from the previous anchor. Allo protocol does not want this to happen.


## Code Snippet
https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/core/Registry.sol#L177-L203

## Tool used

* Manual Review
* Foundry


## Recommendation

Add a verification inside the `Anchor.execute()` function, that when the owner call  `Registry.updateProfileName()` that change a status for the previus `Anchor.sol` and it is not active.